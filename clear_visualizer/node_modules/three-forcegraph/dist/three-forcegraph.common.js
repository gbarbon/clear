'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var d3ScaleChromatic = require('d3-scale-chromatic');
var tinyColor = _interopDefault(require('tinycolor2'));
var three = require('three');
var d3Force3d = require('d3-force-3d');
var graph = _interopDefault(require('ngraph.graph'));
var forcelayout = _interopDefault(require('ngraph.forcelayout'));
var forcelayout3d = _interopDefault(require('ngraph.forcelayout3d'));
var Kapsule = _interopDefault(require('kapsule'));
var accessorFn = _interopDefault(require('accessor-fn'));

var colorStr2Hex = function colorStr2Hex(str) {
  return isNaN(str) ? parseInt(tinyColor(str).toHex(), 16) : str;
};
var colorAlpha = function colorAlpha(str) {
  return isNaN(str) ? tinyColor(str).getAlpha() : 1;
};

// Autoset attribute colorField by colorByAccessor property
// If an object has already a color, don't set it
// Objects can be nodes or links
function autoColorObjects(objects, colorByAccessor, colorField) {
  if (!colorByAccessor || typeof colorField !== 'string') return;

  var colors = d3ScaleChromatic.schemePaired; // Paired color set from color brewer

  var uncoloredObjects = objects.filter(function (obj) {
    return !obj[colorField];
  });
  var objGroups = {};

  uncoloredObjects.forEach(function (obj) {
    objGroups[colorByAccessor(obj)] = null;
  });
  Object.keys(objGroups).forEach(function (group, idx) {
    objGroups[group] = idx;
  });

  uncoloredObjects.forEach(function (obj) {
    obj[colorField] = colors[objGroups[colorByAccessor(obj)] % colors.length];
  });
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var three$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
: {
  Mesh: three.Mesh,
  MeshLambertMaterial: three.MeshLambertMaterial,
  BufferGeometry: three.BufferGeometry,
  BufferAttribute: three.BufferAttribute,
  Matrix4: three.Matrix4,
  Vector3: three.Vector3,
  SphereGeometry: three.SphereGeometry,
  CylinderGeometry: three.CylinderGeometry,
  Line: three.Line,
  LineBasicMaterial: three.LineBasicMaterial,
  QuadraticBezierCurve3: three.QuadraticBezierCurve3,
  CubicBezierCurve3: three.CubicBezierCurve3
};
var ngraph = { graph: graph, forcelayout: forcelayout, forcelayout3d: forcelayout3d };

//

var ForceGraph = Kapsule({

  props: {
    jsonUrl: {
      onChange: function onChange(jsonUrl, state) {
        var _this = this;

        if (jsonUrl && !state.fetchingJson) {
          // Load data asynchronously
          state.fetchingJson = true;
          state.onLoading();

          fetch(jsonUrl).then(function (r) {
            return r.json();
          }).then(function (json) {
            state.fetchingJson = false;
            _this.graphData(json);
          });
        }
      },
      triggerUpdate: false
    },
    graphData: {
      default: {
        nodes: [],
        links: []
      },
      onChange: function onChange(graphData, state) {
        if (graphData.nodes.length || graphData.links.length) {
          console.info('force-graph loading', graphData.nodes.length + ' nodes', graphData.links.length + ' links');
        }

        state.engineRunning = false; // Pause simulation immediately
        state.sceneNeedsRepopulating = true;
        state.simulationNeedsReheating = true;
      }
    },
    numDimensions: {
      default: 3,
      onChange: function onChange(numDim, state) {
        state.simulationNeedsReheating = true;

        var chargeForce = state.d3ForceLayout.force('charge');
        // Increase repulsion on 3D mode for improved spatial separation
        if (chargeForce) {
          chargeForce.strength(numDim > 2 ? -60 : -30);
        }

        if (numDim < 3) {
          eraseDimension(state.graphData.nodes, 'z');
        }
        if (numDim < 2) {
          eraseDimension(state.graphData.nodes, 'y');
        }

        function eraseDimension(nodes, dim) {
          nodes.forEach(function (d) {
            delete d[dim]; // position
            delete d['v' + dim]; // velocity
          });
        }
      }
    },
    nodeRelSize: { default: 4, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // volume per val unit
    nodeId: { default: 'id', onChange: function onChange(_, state) {
        state.simulationNeedsReheating = true;
      }
    },
    nodeVal: { default: 'val', onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    nodeResolution: { default: 8, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // how many slice segments in the sphere's circumference
    nodeColor: { default: 'color', onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    nodeAutoColorBy: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    nodeOpacity: { default: 0.75, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    nodeThreeObject: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkSource: { default: 'source', onChange: function onChange(_, state) {
        state.simulationNeedsReheating = true;
      }
    },
    linkTarget: { default: 'target', onChange: function onChange(_, state) {
        state.simulationNeedsReheating = true;
      }
    },
    linkColor: { default: 'color', onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkAutoColorBy: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkOpacity: { default: 0.2, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkWidth: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // Rounded to nearest decimal. For falsy values use dimensionless line with 1px regardless of distance.
    linkResolution: { default: 6, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // how many radial segments in each line tube's geometry
    linkCurvature: { default: 0, triggerUpdate: false }, // line curvature radius (0: straight, 1: semi-circle)
    linkCurveRotation: { default: 0, triggerUpdate: false }, // line curve rotation along the line axis (0: interection with XY plane, PI: upside down)
    linkMaterial: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkDirectionalParticles: { default: 0, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: { default: 0.01, triggerUpdate: false }, // in link length ratio per frame
    linkDirectionalParticleWidth: { default: 0.5, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkDirectionalParticleColor: {
      onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    },
    linkDirectionalParticleResolution: { default: 4, onChange: function onChange(_, state) {
        state.sceneNeedsRepopulating = true;
      }
    }, // how many slice segments in the particle sphere's circumference
    forceEngine: { default: 'd3', onChange: function onChange(_, state) {
        state.simulationNeedsReheating = true;
      }
    }, // d3 or ngraph
    d3AlphaDecay: { default: 0.0228, triggerUpdate: false, onChange: function onChange(alphaDecay, state) {
        state.d3ForceLayout.alphaDecay(alphaDecay);
      }
    },
    d3AlphaTarget: { default: 0, triggerUpdate: false, onChange: function onChange(alphaTarget, state) {
        state.d3ForceLayout.alphaTarget(alphaTarget);
      }
    },
    d3VelocityDecay: { default: 0.4, triggerUpdate: false, onChange: function onChange(velocityDecay, state) {
        state.d3ForceLayout.velocityDecay(velocityDecay);
      }
    },
    warmupTicks: { default: 0, triggerUpdate: false }, // how many times to tick the force engine at init before starting to render
    cooldownTicks: { default: Infinity, triggerUpdate: false },
    cooldownTime: { default: 15000, triggerUpdate: false }, // ms
    onLoading: { default: function _default() {}, triggerUpdate: false },
    onFinishLoading: { default: function _default() {}, triggerUpdate: false }
  },

  aliases: {
    autoColorBy: 'nodeAutoColorBy'
  },

  methods: {
    // Expose d3 forces for external manipulation
    d3Force: function d3Force(state, forceName, forceFn) {
      if (forceFn === undefined) {
        return state.d3ForceLayout.force(forceName); // Force getter
      }
      state.d3ForceLayout.force(forceName, forceFn); // Force setter
      return this;
    },
    _updateScene: function _updateScene(state) {},
    // reset cooldown state
    resetCountdown: function resetCountdown(state) {
      state.cntTicks = 0;
      state.startTickTime = new Date();
      state.engineRunning = true;
      return this;
    },
    tickFrame: function tickFrame(state) {
      var isD3Sim = state.forceEngine !== 'ngraph';

      if (state.engineRunning) {
        layoutTick();
      }
      updatePhotons();

      return this;

      //

      function layoutTick() {
        if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime) {
          state.engineRunning = false; // Stop ticking graph
        } else {
          state.layout[isD3Sim ? 'tick' : 'step'](); // Tick it
        }

        // Update nodes position
        state.graphData.nodes.forEach(function (node) {
          var obj = node.__threeObj;
          if (!obj) return;

          var pos = isD3Sim ? node : state.layout.getNodePosition(node[state.nodeId]);

          obj.position.x = pos.x;
          obj.position.y = pos.y || 0;
          obj.position.z = pos.z || 0;
        });

        // Update links position
        var linkCurvatureAccessor = accessorFn(state.linkCurvature);
        var linkCurveRotationAccessor = accessorFn(state.linkCurveRotation);
        state.graphData.links.forEach(function (link) {
          var line = link.__lineObj;
          if (!line) return;

          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? 'source' : 'from'];
          var end = pos[isD3Sim ? 'target' : 'to'];

          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

          link.__curve = null; // Wipe curve ref from object

          if (line.type === 'Line') {
            // Update line geometry
            var curvature = linkCurvatureAccessor(link);
            var curveResolution = 30; // # line segments

            if (!curvature) {
              var linePos = line.geometry.getAttribute('position');
              if (!linePos || !linePos.array || linePos.array.length !== 6) {
                line.geometry.addAttribute('position', linePos = new three$1.BufferAttribute(new Float32Array(2 * 3), 3));
              }

              linePos.array[0] = start.x;
              linePos.array[1] = start.y || 0;
              linePos.array[2] = start.z || 0;
              linePos.array[3] = end.x;
              linePos.array[4] = end.y || 0;
              linePos.array[5] = end.z || 0;

              linePos.needsUpdate = true;
            } else {
              // bezier curve line
              var vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);
              var vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);

              var l = vStart.distanceTo(vEnd); // line length

              var curve = void 0;
              var curveRotation = linkCurveRotationAccessor(link);

              if (l > 0) {
                var dx = end.x - start.x;
                var dy = end.y - start.y || 0;

                var vLine = new three$1.Vector3().subVectors(vEnd, vStart);

                var cp = vLine.clone().multiplyScalar(curvature).cross(dx !== 0 || dy !== 0 ? new three$1.Vector3(0, 0, 1) : new three$1.Vector3(0, 1, 0)) // avoid cross-product of parallel vectors (prefer Z, fallback to Y)
                .applyAxisAngle(vLine.normalize(), curveRotation) // rotate along line axis according to linkCurveRotation
                .add(new three$1.Vector3().addVectors(vStart, vEnd).divideScalar(2));

                curve = new three$1.QuadraticBezierCurve3(vStart, cp, vEnd);
              } else {
                // Same point, draw a loop
                var d = curvature * 70;
                var endAngle = -curveRotation; // Rotate clockwise (from Z angle perspective)
                var startAngle = endAngle + Math.PI / 2;

                curve = new three$1.CubicBezierCurve3(vStart, new three$1.Vector3(d * Math.cos(startAngle), d * Math.sin(startAngle), 0).add(vStart), new three$1.Vector3(d * Math.cos(endAngle), d * Math.sin(endAngle), 0).add(vStart), vEnd);
              }

              line.geometry.setFromPoints(curve.getPoints(curveResolution));
              link.__curve = curve;
            }
            line.geometry.computeBoundingSphere();
          } else {
            // Update cylinder geometry
            // links with width ignore linkCurvature because TubeGeometries can't be updated

            var _vStart = new three$1.Vector3(start.x, start.y || 0, start.z || 0);
            var _vEnd = new three$1.Vector3(end.x, end.y || 0, end.z || 0);
            var distance = _vStart.distanceTo(_vEnd);

            line.position.x = _vStart.x;
            line.position.y = _vStart.y;
            line.position.z = _vStart.z;
            line.lookAt(_vEnd);
            line.scale.z = distance;
          }
        });
      }

      function updatePhotons() {
        // update link particle positions
        var particleSpeedAccessor = accessorFn(state.linkDirectionalParticleSpeed);
        state.graphData.links.forEach(function (link) {
          var photons = link.__photonObjs;
          if (!photons || !photons.length) return;

          var pos = isD3Sim ? link : state.layout.getLinkPosition(state.layout.graph.getLink(link.source, link.target).id);
          var start = pos[isD3Sim ? 'source' : 'from'];
          var end = pos[isD3Sim ? 'target' : 'to'];

          if (!start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link

          var particleSpeed = particleSpeedAccessor(link);

          var getPhotonPos = link.__curve ? function (t) {
            return link.__curve.getPoint(t);
          } // interpolate along bezier curve
          : function (t) {
            // straight line: interpolate linearly
            var iplt = function iplt(dim, start, end, t) {
              return start[dim] + (end[dim] - start[dim]) * t || 0;
            };
            return {
              x: iplt('x', start, end, t),
              y: iplt('y', start, end, t),
              z: iplt('z', start, end, t)
            };
          };

          photons.forEach(function (photon, idx) {
            var photonPosRatio = photon.__progressRatio = ((photon.__progressRatio || idx / photons.length) + particleSpeed) % 1;

            var pos = getPhotonPos(photonPosRatio);
            ['x', 'y', 'z'].forEach(function (dim) {
              return photon.position[dim] = pos[dim];
            });
          });
        });
      }
    }
  },

  stateInit: function stateInit() {
    return {
      d3ForceLayout: d3Force3d.forceSimulation().force('link', d3Force3d.forceLink()).force('charge', d3Force3d.forceManyBody()).force('center', d3Force3d.forceCenter()).stop(),
      engineRunning: false,
      sceneNeedsRepopulating: true,
      simulationNeedsReheating: true
    };
  },

  init: function init(threeObj, state) {
    // Main three object to manipulate
    state.graphScene = threeObj;
  },
  update: function update(state) {
    state.engineRunning = false; // pause simulation

    if (state.sceneNeedsRepopulating) {
      state.sceneNeedsRepopulating = false;

      if (state.nodeAutoColorBy !== null) {
        // Auto add color to uncolored nodes
        autoColorObjects(state.graphData.nodes, accessorFn(state.nodeAutoColorBy), state.nodeColor);
      }
      if (state.linkAutoColorBy !== null) {
        // Auto add color to uncolored links
        autoColorObjects(state.graphData.links, accessorFn(state.linkAutoColorBy), state.linkColor);
      }

      // Clear the scene
      var deallocate = function deallocate(obj) {
        if (obj.geometry) {
          obj.geometry.dispose();
        }
        if (obj.material) {
          obj.material.dispose();
        }
        if (obj.texture) {
          obj.texture.dispose();
        }
        if (obj.children) {
          obj.children.forEach(deallocate);
        }
      };
      while (state.graphScene.children.length) {
        var obj = state.graphScene.children[0];
        state.graphScene.remove(obj);
        deallocate(obj);
      }

      // Add WebGL objects
      var customNodeObjectAccessor = accessorFn(state.nodeThreeObject);
      var valAccessor = accessorFn(state.nodeVal);
      var colorAccessor = accessorFn(state.nodeColor);
      var sphereGeometries = {}; // indexed by node value
      var sphereMaterials = {}; // indexed by color
      state.graphData.nodes.forEach(function (node) {
        var customObj = customNodeObjectAccessor(node);

        var obj = void 0;
        if (customObj) {
          obj = customObj;

          if (state.nodeThreeObject === obj) {
            // clone object if it's a shared object among all nodes
            obj = obj.clone();
          }
        } else {
          // Default object (sphere mesh)
          var val = valAccessor(node) || 1;
          if (!sphereGeometries.hasOwnProperty(val)) {
            sphereGeometries[val] = new three$1.SphereGeometry(Math.cbrt(val) * state.nodeRelSize, state.nodeResolution, state.nodeResolution);
          }

          var color = colorAccessor(node);
          if (!sphereMaterials.hasOwnProperty(color)) {
            sphereMaterials[color] = new three$1.MeshLambertMaterial({
              color: colorStr2Hex(color || '#ffffaa'),
              transparent: true,
              opacity: state.nodeOpacity * colorAlpha(color)
            });
          }

          obj = new three$1.Mesh(sphereGeometries[val], sphereMaterials[color]);
        }

        obj.__graphObjType = 'node'; // Add object type
        obj.__data = node; // Attach node data

        state.graphScene.add(node.__threeObj = obj);
      });

      var customLinkMaterialAccessor = accessorFn(state.linkMaterial);
      var linkColorAccessor = accessorFn(state.linkColor);
      var linkWidthAccessor = accessorFn(state.linkWidth);
      var linkParticlesAccessor = accessorFn(state.linkDirectionalParticles);
      var linkParticleWidthAccessor = accessorFn(state.linkDirectionalParticleWidth);
      var linkParticleColorAccessor = accessorFn(state.linkDirectionalParticleColor);

      var lineMaterials = {}; // indexed by link color
      var cylinderGeometries = {}; // indexed by link width
      var particleMaterials = {}; // indexed by link color
      var particleGeometries = {}; // indexed by particle width
      state.graphData.links.forEach(function (link) {
        // Add line
        var color = linkColorAccessor(link);
        var linkWidth = Math.ceil(linkWidthAccessor(link) * 10) / 10;

        var useCylinder = !!linkWidth;

        var geometry = void 0;
        if (useCylinder) {
          if (!cylinderGeometries.hasOwnProperty(linkWidth)) {
            var r = linkWidth / 2;
            geometry = new three$1.CylinderGeometry(r, r, 1, state.linkResolution, 1, false);
            geometry.applyMatrix(new three$1.Matrix4().makeTranslation(0, 1 / 2, 0));
            geometry.applyMatrix(new three$1.Matrix4().makeRotationX(Math.PI / 2));
            cylinderGeometries[linkWidth] = geometry;
          }
          geometry = cylinderGeometries[linkWidth];
        } else {
          // Use plain line (constant width)
          geometry = new three$1.BufferGeometry();
        }

        var lineMaterial = customLinkMaterialAccessor(link);
        if (!lineMaterial) {
          if (!lineMaterials.hasOwnProperty(color)) {
            var lineOpacity = state.linkOpacity * colorAlpha(color);
            lineMaterials[color] = new three$1.MeshLambertMaterial({
              color: colorStr2Hex(color || '#f0f0f0'),
              transparent: lineOpacity < 1,
              opacity: lineOpacity,
              depthWrite: lineOpacity >= 1 // Prevent transparency issues
            });
          }
          lineMaterial = lineMaterials[color];
        }

        var line = new three$1[useCylinder ? 'Mesh' : 'Line'](geometry, lineMaterial);

        line.renderOrder = 10; // Prevent visual glitches of dark lines on top of nodes by rendering them last

        line.__graphObjType = 'link'; // Add object type
        line.__data = link; // Attach link data

        state.graphScene.add(link.__lineObj = line);

        // Add photon particles
        var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));
        var photonR = Math.ceil(linkParticleWidthAccessor(link) * 10) / 10 / 2;
        var photonColor = linkParticleColorAccessor(link) || color || '#f0f0f0';

        if (!particleGeometries.hasOwnProperty(photonR)) {
          particleGeometries[photonR] = new three$1.SphereGeometry(photonR, state.linkDirectionalParticleResolution, state.linkDirectionalParticleResolution);
        }
        var particleGeometry = particleGeometries[photonR];

        if (!particleMaterials.hasOwnProperty(color)) {
          particleMaterials[color] = new three$1.MeshLambertMaterial({
            color: colorStr2Hex(photonColor),
            transparent: true,
            opacity: state.linkOpacity * 3
          });
        }
        var particleMaterial = particleMaterials[color];

        var photons = [].concat(toConsumableArray(Array(numPhotons))).map(function () {
          return new three$1.Mesh(particleGeometry, particleMaterial);
        });
        photons.forEach(function (photon) {
          return state.graphScene.add(photon);
        });
        link.__photonObjs = photons;
      });
    }

    if (state.simulationNeedsReheating) {
      state.simulationNeedsReheating = false;
      state.engineRunning = false; // Pause simulation

      // parse links
      state.graphData.links.forEach(function (link) {
        link.source = link[state.linkSource];
        link.target = link[state.linkTarget];
      });

      // Feed data to force-directed layout
      var isD3Sim = state.forceEngine !== 'ngraph';
      var layout = void 0;
      if (isD3Sim) {
        // D3-force
        (layout = state.d3ForceLayout).stop().alpha(1) // re-heat the simulation
        .numDimensions(state.numDimensions).nodes(state.graphData.nodes);

        // add links (if link force is still active)
        var linkForce = state.d3ForceLayout.force('link');
        if (linkForce) {
          linkForce.id(function (d) {
            return d[state.nodeId];
          }).links(state.graphData.links);
        }
      } else {
        // ngraph
        var _graph = ngraph.graph();
        state.graphData.nodes.forEach(function (node) {
          _graph.addNode(node[state.nodeId]);
        });
        state.graphData.links.forEach(function (link) {
          _graph.addLink(link.source, link.target);
        });
        layout = ngraph['forcelayout' + (state.numDimensions === 2 ? '' : '3d')](_graph);
        layout.graph = _graph; // Attach graph reference to layout
      }

      for (var i = 0; i < state.warmupTicks; i++) {
        layout[isD3Sim ? 'tick' : 'step']();
      } // Initial ticks before starting to render

      state.layout = layout;
      this.resetCountdown();

      state.onFinishLoading();
    }

    state.engineRunning = true; // resume simulation
  }
});

function fromKapsule (kapsule) {
  var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object;
  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var FromKapsule = function (_baseClass) {
    inherits(FromKapsule, _baseClass);

    function FromKapsule() {
      var _ref;

      classCallCheck(this, FromKapsule);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = possibleConstructorReturn(this, (_ref = FromKapsule.__proto__ || Object.getPrototypeOf(FromKapsule)).call.apply(_ref, [this].concat(args)));

      _this.__kapsuleInstance = kapsule().apply(undefined, [].concat(toConsumableArray(initKapsuleWithSelf ? [_this] : []), args));
      return _this;
    }

    return FromKapsule;
  }(baseClass);

  // attach kapsule props/methods to class prototype


  Object.keys(kapsule()).forEach(function (m) {
    return FromKapsule.prototype[m] = function () {
      var _kapsuleInstance;

      var returnVal = (_kapsuleInstance = this.__kapsuleInstance)[m].apply(_kapsuleInstance, arguments);

      return returnVal === this.__kapsuleInstance ? this // chain based on this class, not the kapsule obj
      : returnVal;
    };
  });

  return FromKapsule;
}

var threeForcegraph = fromKapsule(ForceGraph, three.Group, true);

module.exports = threeForcegraph;
